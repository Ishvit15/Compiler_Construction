program -> module_declerations other_modules driver_module other_modules
module_declerations -> module_decleration module_declerations 
module_declerations -> ε
module_decleration -> DECLARE MODULE ID SEMICOL
other_modules -> module other_modules 
other_modules -> ε
driver_module -> DRIVERDEF DRIVER PROGRAM DRIVERENDDEF module_def
module -> DEF MODULE ID ENDDEF TAKES INPUT SQBO input_plist SQBC SEMICOL ret module_def
ret -> RETURNS SQBo output_plist SQBC SEMICOL 
ret -> ε
input_plist -> ID COLON data_type n1
n1 -> COMMA ID COLON data_type n1 
n1 -> ε
output_plist -> ID COLON type n2
n2 -> comma ID COLON type n2
n2 -> ε
data_type -> INTEGER 
data_type -> REAL
data_type -> BOOLEAN
data_type -> ARRAY SQBO range_arrays SQBC OF type
range_arrays -> index_arr RANGEOP index_arr
type -> INTEGER 
type -> REAL
type -> BOOLEAN
module_def -> START statements END
statements -> statement statements 
statements -> ε
statement -> io_stmt 
statement -> simple_stmt
statement -> declare_stmt
statement -> conditional_stmt
statement -> iterative_stmt
io_stmt -> GET_VALUE BO ID SEMICOL 
io_stmt -> PRINT BO var_print BC SEMICOL
bool_const -> TRUE 
bool_const -> FALSE
id_num_rnum -> ID 
id_num_rnum -> NUM
id_num_rnum -> RNUM
array_element_for_print -> ID SQBO new_index SQBC
var_print -> ID p1
var_print -> NUM
var_print -> RNUM 
var_print -> book_const
p1 -> SQBO new_index SQBC 
p1 -> ε
simple_stmt -> assignment_stmt
simple_stmt -> module_reuse_stmt
assignment_stmt -> ID which_stmt
which_stmt -> lvalue_id_stmt
which_stmt -> lvalue_arr_stmt
lvalue_id_stmt-> ASSIGNOP expression SEMICOL
lvalue_arr_stmt -> SQBO element_index_with_exp SQBC ASSIGNOP expression SEMICOL
index_arr -> sign
index_arr -> new_index
new_index -> NUM
index -> ID
sign -> PLUS
sign -> MINUS
sign -> ε
module_reuse_stmt -> optional USE MODULE ID WITH PARAMETERS id_list SEMICOL
optional -> SQBO id_list SQBC ASSIGNOP
optional -> ε
id_list -> ID n3
n3 -> COMMA ID n3
n3 -> ε
expression -> arithmetic_exp_or_boolean_exp
expression -> u
u -> unary_op new_nt
unary_op -> PLUS 
unary_op -> MINUS
new_nt -> BO arithmetic_exp BC
new_nt -> var_id_num 
\\ DOING RULE 27


